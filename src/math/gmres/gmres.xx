export module math.gmres;

import std;

import math.blas;
import math.core;
import utils.assert;

namespace math::gmres {

template <typename Real>
inline void solve_impl(
    std::size_t n,
    const Real* A, const Real* b, Real* x, std::size_t m
) {
    static constexpr Real zero{};
    static constexpr Real one{1};

    // Residual
    std::vector<Real> r(n);
    blas::Traits<Real>::copy(n, b, 1, r.data(), 1);

    // r = b - A * x
    blas::Traits<Real>::gemv(
        blas::Layout::CblasRowMajor,
        blas::Transpose::CblasNoTrans,
        n, n, -one, A,
        n,
        x, 1,
        one, r.data(), 1
    );

    const auto b_norm = blas::Traits<Real>::nrm2(n, b, 1);

    std::vector<Real> sn(m, zero);
    std::vector<Real> cs(m, zero);
    std::vector<Real> e1(m + 1, zero);
    e1[0] = one;
    std::vector<Real> e(m + 1, zero);
    e[0] = blas::Traits<Real>::nrm2(n, r.data(), 1) / b_norm;
    const auto r_norm = blas::Traits<Real>::nrm2(n, r.data(), 1);

    std::vector<Real> Q(n * (m + 1));
    blas::Traits<Real>::axpy(n, one / r_norm, r.data(), 1, Q.data(), 1);


    std::vector<Real> beta(e1.size(), zero);
    beta[0] = r_norm;

    std::vector<Real> H((m + 1) * m);

    const auto arnoldi = [n, m, &Q, &H, A] (std::size_t k) {
        Real* q = Q.data() + n * (k + 1); // Q(:, k+1)
        Real* h = H.data() + (m + 1) * k; // H(1:k+1, k)

        blas::Traits<Real>::gemv(
            blas::Layout::CblasRowMajor,
            blas::Transpose::CblasNoTrans,
            n, n, one, A,
            n,
            Q.data() + n * k, 1,
            one, q, 1
        );

        for (auto i = 0uz; i <= k; ++i) {
            const Real* Qi = Q.data() + n * i;
            h[i] = blas::Traits<Real>::dot(n, q, 1, Qi, 1);
            for (auto j = 0uz; j < n; ++j) q[j] -= h[i] * Qi[j];
        }

        h[k + 1] = blas::Traits<Real>::nrm2(n, q, 1);
        for (auto i = 0uz; i < n; ++i) q[i] /= h[k + 1];
    }; // <-- arnoldi(k)
    const auto apply_givens_rotation = [m, &H, &cs, &sn] (std::size_t k) {
        Real* h = H.data() + (m + 1) * k;
        for (auto i = 0uz; i < k; ++i) {
            const auto temp =  cs[i] * h[i] + sn[i] * h[i + 1];
            h[i + 1] =        -sn[i] * h[i] + cs[i] * h[i + 1];
            h[i] = temp;
        }

        // givens_rotation()
        const auto t = std::sqrt(h[k] * h[k] + h[k + 1] * h[k + 1]);
        cs[k] = h[k] / t;
        sn[k] = h[k + 1] / t;

        h[k] = cs[k] * h[k] + sn[k] * h[k + 1];
        h[k + 1] = zero;
    }; // <-- apply_givens_rotation(k)

    std::size_t k;
    for (k = 0; k < m; ++k) {
        arnoldi(k);
        apply_givens_rotation(k);
        beta[k + 1] = -sn[k] * beta[k];
        beta[k]     =  cs[k] * beta[k];

        e[k + 1] = std::abs(beta[k + 1]) / b_norm;
        // std::println("error={}", e[k+1]);
        if (e[k + 1] <= 1e-7) break;
    }

    if (k == m) {
        throw std::runtime_error{ "GMRES did not converge" };
    }

    std::vector<Real> y(k + 1, zero);
    for (auto i = 0uz; i < k + 1; ++i) {
        const auto I = k - i;
        Real lhs = zero;
        for (auto j = 0uz; j < i; ++j) {
            const auto J = k - j;
            lhs += y[J] * H[I + J * (m + 1)];
        }
        y[I] = (beta[I] - lhs) / H[I + I * (m + 1)];
    }

    for (auto i = 0uz; i < n; ++i) {
        for (auto j = 0uz; j < k + 1; ++j) {
            x[i] += Q[i + j * n] * y[j];
        }
    }
} // <-- void solve_impl(n, A, b, x)

/// @brief Solve Ax = b for x with GMRES
export
template <vector V>
inline
void solve(
    V&& A,
    vector_like<V> auto&& b,
    mut_vector_like<V> auto&& x,
    std::size_t max_iterations = 15
) {
    utils::assert::debug(A.size() == b.size() * b.size());
    utils::assert::debug(x.size() == b.size());
    solve_impl(x.size(), A.data(), b.data(), x.data(), max_iterations);
} // <-- solve(A, b, x, max_iterations)

export
template <vector V>
[[nodiscard]]
inline
auto solve(
    V&& A, vector_like<V> auto&& b, std::size_t max_iterations = 15
) {
    std::vector<RealFor<V>> x(b.size());
    solve(A, b, x, max_iterations);
    return x;
} // <-- solve(A, b, max_iterations)

} // <-- namespace math::gmres
